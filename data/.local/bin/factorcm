#!/bin/zsh

RED='\033[1;31m'
BLUE='\033[1;34m'
CYAN='\033[1;36m'
NC='\033[0m'

# get project parameters
P_NAME=$1
P_DEMONAME=$P_NAME
G_NAME="FactorCMake"
G_VERSION="v0.1.0"

struct_summary()
{
    echo -e "\t${CYAN}./${P_DEMONAME}/${NC}"
    echo -e "\t├── ${CYAN}bin/${NC}"
    echo -e "\t│   └── ${CYAN}${P_DEMONAME}${NC}"
    echo -e "\t├── ${CYAN}build/${NC}"
    echo -e "\t├── ${CYAN}docs/${NC}"
    echo -e "\t│   └── ${P_DEMONAME}"
    echo -e "\t├── ${CYAN}include/${NC}"
    echo -e "\t│   └── pch.h"
    echo -e "\t├── ${CYAN}source/${NC}"
    echo -e "\t│   └── ${CYAN}${P_DEMONAME}/${NC}"
    echo -e "\t│       └── main.cc"
    echo -e "\t├── ${CYAN}vendors/${NC}"
    echo -e "\t├── .gitignore"
    echo -e "\t├── CMakeLists.txt"
    echo -e "\t├── CMP.cmake"
    echo -e "\t├── cotire.cmake"
    echo -e "\t└── README.md"
    echo -e "\n\n"
    echo -e "\tBuild and run the project with the following commands:"
    echo -e "\t${CYAN}\$ cd ./${P_DEMONAME}/build${NC}"
    echo -e "\t${CYAN}\$ cmake ..${NC}"
    echo -e "\t${CYAN}\$ make${NC}"
    echo -e "\t${CYAN}\$ make run${NC}"
}

usage()
{
    echo -e "${BLUE}[${CYAN}?${BLUE}]${NC} Usage: $0 <PROJECT>\n"
    struct_summary
    echo -e "\n"
    exit 1
}

duplicated()
{
    echo -e "${BLUE}[${RED}x${BLUE}]${NC} Directory already exists.\n"
    exit 1
}


## ===================================================================
## ENTRYPOINT
## ===================================================================


# print header
echo $CYAN
figlet "$G_NAME"
echo "C++ CMake Project Scaffold Generator $G_VERSION"
echo $NC
[[ -z "$P_NAME" ]] && P_DEMONAME="demo" && usage # terminate if no project supplied


# project header
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Project: $P_NAME"


# creating project directory structure
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating directory structure..."
[ -d "$P_NAME" ] && duplicated
mkdir -p $P_NAME/bin $P_NAME/build $P_NAME/docs $P_NAME/include $P_NAME/vendors $P_NAME/source/$P_NAME


## ===================================================================
## CREATING PROJECT SOURCE FILES
## ===================================================================

##
## source/<project>/main.cc
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}source/$P_NAME/main.cc${NC}"
cat >> $P_NAME/source/$P_NAME/main.cc <<EOT
#include "pch.h"

int main(int argc, char** argv)
{
    std::cout << "Project ${P_NAME} built with ${G_NAME} ${G_VERSION}..." << std::endl;
}
EOT

##
## include/pch.h
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}include/pch.h${NC}"
cat >> $P_NAME/include/pch.h <<EOT
#pragma once

#include <iostream>
#include <memory>
#include <string>
#include <vector>
EOT

##
## Man page
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating man page"
FDATE=`date +"%d %B %Y"`
cat >> $P_NAME/docs/$P_NAME <<EOT
.\" Manpage for ${P_NAME}.
.\" Contact ${USER}@${HOST} to correct errors or typos.
.TH man 1 "${FDATE}" "1.0" "${P_NAME} man page"
.SH NAME
${P_NAME} \- lorem ipsum dolor sit amet
.SH SYNOPSIS
${P_NAME} [OPTIONS...]
.SH DESCRIPTION
${P_NAME} is a template C++ software generated by the ${G_NAME} ${G_VERSION}.
.SH OPTIONS
Description of all options that can change ${P_NAME} behavior.
.SH SEE ALSO
Any references you may want to include.
.SH BUGS
No known bugs.
.SH AUTHOR
Software written by ${USER} <${USER}@${HOST}>
EOT


##
## .gitignore
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}.gitignore${NC}"
cat >> $P_NAME/.gitignore <<EOT
.vscode/
build/*
bin/*
*.sh
EOT


##
## README file
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}README.md${NC}"
cat >> $P_NAME/README.md <<EOT
# README

Demo readme file for project documentation.
EOT


## ===================================================================
## CREATING PROJECT BUILD FILES
## ===================================================================


##
## CMakeLists.txt
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}CMakeLists.txt${NC}"
cat >> $P_NAME/CMakeLists.txt <<EOT
## ====================================================
## BASIC PROJECT SETUP
## ====================================================

##
## Local dependencies
include(CPM.cmake)    # link dependencies from github
include(cotire.cmake) # manage precompiled headers

##
## CMake and cpp versions
cmake_minimum_required(VERSION 3.9.1)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

##
## Define project
set(EXEC_NAME ${P_NAME})
project(\${EXEC_NAME} VERSION 1.0)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \${CMAKE_CURRENT_SOURCE_DIR}/bin) # ship libraries with the binary

##
## Environment Specific Code
if (NOT CMAKE_BUILD_TYPE STREQUAL "Release")
    add_compile_definitions(ENABLE_CUSTOM_ASSERTS)  # don't enable this feature for release
endif ()

if(CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS)
    install(PROGRAMS ${CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS} DESTINATION bin COMPONENT System)
endif(CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS)

set(CMAKE_INSTALL_RPATH "$ORIGIN")
set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)

##
## Build Project
set(SRC_DIR \${CMAKE_CURRENT_SOURCE_DIR}/source)
set(HDR_DIR \${CMAKE_CURRENT_SOURCE_DIR}/include)
file(GLOB_RECURSE SRCS \${SRC_DIR}/*.cc)
add_executable(\${EXEC_NAME} \${SRCS})
target_include_directories(\${EXEC_NAME} PUBLIC \${SRC_DIR})
target_include_directories(\${EXEC_NAME} PUBLIC \${HDR_DIR})

set_target_properties(\${EXEC_NAME} PROPERTIES RUNTIME_OUTPUT_DIRECTORY "\${CMAKE_CURRENT_SOURCE_DIR}/bin")
set_target_properties(\${EXEC_NAME} PROPERTIES LIBRARY_OUTPUT_DIRECTORY "\${CMAKE_CURRENT_SOURCE_DIR}/bin")

## ====================================================
## EXTERNAL DEPENDENCIES
## ====================================================

##
## Build static library and link it to the executable
#set(LIBDEMO_NAME demo)
#set(LIBDEMO_SRC_DIR \${CMAKE_CURRENT_SOURCE_DIR}/source/demo/)
#set(LIBDEMO_HDR_DIR \${CMAKE_CURRENT_SOURCE_DIR}/source/demo/)
#
#file(GLOB_RECURSE LIBDEMO_SRC_FILES \${LIBDEMO_SRC_DIR}/*.cc)
#add_library(\${LIBDEMO_NAME} STATIC \${LIBDEMO_SRC_FILES})
#
#target_include_directories(\${LIBDEMO_NAME} PUBLIC \${LIBDEMO_HDR_DIR})
#target_include_directories(\${LIBDEMO_NAME} PUBLIC \${HDR_DIR})
#target_link_libraries(\${EXEC_NAME} PUBLIC \${LIBDEMO_NAME})


##
## Link external library from system path
#find_library(LIBSDL SDL2)
#target_link_libraries(\${EXEC_NAME} PUBLIC \${LIBSDL})

##
## Link external library from github
#CPMAddPackage("gh:catchorg/Catch2@2.13.4")
#target_link_libraries(\${EXEC_NAME} PUBLIC Catch2)

##
## Link external header-only library
#set(LIBSTB_HDR_DIR \${CMAKE_CURRENT_SOURCE_DIR}/vendors/stb)
#target_include_directories(\${EXEC_NAME} PUBLIC \${LIBSTB_HDR_DIR})

## ====================================================
## BUILD UTILS
## ====================================================

##
## Creating precompiled headers
set_target_properties(\${EXEC_NAME} PROPERTIES COTIRE_CXX_PREFIX_HEADER_INIT "\${CMAKE_CURRENT_SOURCE_DIR}/include/pch.h")
cotire(\${EXEC_NAME})

##
## Create a run.sh script
set(SHELL /bin/zsh)
set(RUNSCRIPT \${CMAKE_CURRENT_SOURCE_DIR}/run.sh)
file(WRITE \${RUNSCRIPT} "#!\${SHELL}\n")
file(APPEND \${RUNSCRIPT} "cd \$(dirname \"\$0\")/bin\n")
file(APPEND \${RUNSCRIPT} "./\${EXEC_NAME}\n")

##
## Add 'make run' command
add_custom_target(run
    COMMAND chmod +x \${CMAKE_CURRENT_SOURCE_DIR}/run.sh && \${CMAKE_CURRENT_SOURCE_DIR}/run.sh
    DEPENDS \${CMAKE_CURRENT_SOURCE_DIR}/bin/\${EXEC_NAME}
    WORKING_DIRECTORY \${CMAKE_PROJECT_DIR}
)

##
## Add 'make clear' command
add_custom_target(clear
    COMMAND rm -Rf \${CMAKE_CURRENT_SOURCE_DIR}/bin/* \${CMAKE_CURRENT_SOURCE_DIR}/build/* \${CMAKE_CURRENT_SOURCE_DIR}/*.sh
    WORKING_DIRECTORY \${CMAKE_PROJECT_DIR}
)
EOT


##
## CPM.cmake (0.34.3) - try download first, or else build local
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating CMP.cmake"
(cd ${P_NAME} && curl -LJO --silent https://github.com/cpm-cmake/CPM.cmake/releases/download/v0.34.3/CPM.cmake && cd ..)

if [ ! -f $P_NAME/CPM.cmake ]; then
    cat >> $P_NAME/CPM.cmake <<EOT
set(CPM_DOWNLOAD_VERSION 0.34.3)

if(CPM_SOURCE_CACHE)
  # Expand relative path. This is important if the provided path contains a tilde (~)
  get_filename_component(CPM_SOURCE_CACHE \${CPM_SOURCE_CACHE} ABSOLUTE)
  set(CPM_DOWNLOAD_LOCATION "\${CPM_SOURCE_CACHE}/cpm/CPM_\${CPM_DOWNLOAD_VERSION}.cmake")
elseif(DEFINED ENV{CPM_SOURCE_CACHE})
  set(CPM_DOWNLOAD_LOCATION "\$ENV{CPM_SOURCE_CACHE}/cpm/CPM_\${CPM_DOWNLOAD_VERSION}.cmake")
else()
  set(CPM_DOWNLOAD_LOCATION "\${CMAKE_BINARY_DIR}/cmake/CPM_\${CPM_DOWNLOAD_VERSION}.cmake")
endif()

if(NOT (EXISTS \${CPM_DOWNLOAD_LOCATION}))
  message(STATUS "Downloading CPM.cmake to \${CPM_DOWNLOAD_LOCATION}")
  file(DOWNLOAD
       https://github.com/cpm-cmake/CPM.cmake/releases/download/v\${CPM_DOWNLOAD_VERSION}/CPM.cmake
       \${CPM_DOWNLOAD_LOCATION}
  )
endif()

include(\${CPM_DOWNLOAD_LOCATION})
EOT
fi


##
## cotire.cmake (v1.8.1)
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}cotire.cmake${NC}"
(cd ${P_NAME} && curl -LJO --silent https://github.com/sakra/cotire/releases/download/cotire-1.8.1/cotire.cmake && cd ..)


##
## Terminated
echo -e "${BLUE}[${CYAN}!${BLUE}]${NC} All done :3\n"
struct_summary
echo -e "\n"