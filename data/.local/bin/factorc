#!/bin/zsh

RED='\033[1;31m'
BLUE='\033[1;34m'
CYAN='\033[1;36m'
NC='\033[0m'

# get project parameters
P_NAME=$1
P_MODE=$2
P_DEMONAME=$P_NAME

struct_summary()
{
    echo -e "\t${BLUE}./${P_DEMONAME}/${NC}"
    echo -e "\t├── ${BLUE}bin/${NC}"
    echo -e "\t│   └── ${BLUE}${P_DEMONAME}${NC}"
    echo -e "\t├── ${BLUE}doc/${NC}"
    echo -e "\t│   └── ${P_DEMONAME}"
    echo -e "\t├── ${BLUE}inc/${NC}"
    echo -e "\t├── ${BLUE}lib/${NC}"
    echo -e "\t├── ${BLUE}obj/${NC}"
    echo -e "\t├── ${BLUE}src/${NC}"
    echo -e "\t│   └── ${P_DEMONAME}.c"
    echo -e "\t├── .gitignore"
    echo -e "\t├── Makefile"
    echo -e "\t└── README.md"
}

usage()
{
    echo -e "${BLUE}[${CYAN}?${BLUE}]${NC} Usage: $0 <PROJECT> [MODE]\n"
    echo -e "\tPROJECT\t- Project name"
    echo -e "\tMODE\t- Create bare minimum project code for one of the available modes:"
    echo -e "\t\t\t\tgetopt"
    echo -e "\t\t\t\tcurses"
    echo -e "\t\t\t\tsdl"
    echo -e "\t\t\t\topengl"
    echo -e "\n\tSTRUCTURE\n"
    struct_summary
    echo -e "\n"
    exit 1
}

duplicated()
{
    echo -e "${BLUE}[${RED}x${BLUE}]${NC} Directory already exists.\n"
    exit 1
}

# print header
echo $BLUE
figlet "FactorC"
echo "C project scaffold generator v0.5.1"
echo $NC
[[ -z "$P_NAME" ]] && P_DEMONAME="demo" && usage

# building project mode
P_LIB=""
P_INC="#include <stdlib.h>\n"
P_STDIO="true"
read -r -d '' P_CODE << EOD
int main(int argc, char **argv)
{
    puts("Hello World!");
    return 0;
}
EOD

tabs 4

### CURSES
if [[ $P_MODE == "curses" || $P_MODE == "ncurses" ]]; then
    P_STDIO="false"
    P_LIB="${P_LIB} -lncurses"
    P_INC=`echo -e "#define _XOPEN_SOURCE   600\n#define _POSIX_C_SOURCE 200112L\n\n#include <unistd.h>\n${P_INC}#include <ncurses.h>\n"`
    read -r -d '' P_CODE << EOD
void wait_millis(int ms) { usleep(ms * 1000); }

int main(int argc, char **argv)
{
    int running = 1;
    char input;

    initscr();
    cbreak();
	noecho();
    curs_set(0);
    start_color();

    // id, foreground, background
    init_pair(1, COLOR_CYAN, COLOR_WHITE);
    
    int counter = 0;
    while (running) {
        clear();

        if (input) {
            attron(COLOR_PAIR(1));
            mvaddch(1, 1, input);
            attroff(COLOR_PAIR(1));
        }

        mvprintw(4, 10, "%d", counter);

        attron(A_BOLD);
        mvprintw(5, 10, "Hello World!");
        attroff(A_BOLD);
        refresh();

        timeout(0);
        input = getch();
        counter++;

        if (input == 'q') running = 0;
        wait_millis(1000 / 30);
    }
    
    endwin();
    return 0;
}
EOD

### SDL
elif [[ $P_MODE == "sdl" ]]; then
    P_STDIO="false"
    P_LIB="${P_LIB} -lSDL2"
    P_INC=`echo -e "${P_INC}#include <SDL2/SDL.h>\n"`
    read -r -d '' P_CODE << EOD
int main(int argc, char** argv)
{
    const int SCREEN_W = 1280;
    const int SCREEN_H = 720;

    SDL_Window *window = NULL;
    SDL_Renderer *renderer = NULL;
    SDL_Event event;
    SDL_Rect rect;

    int running = 1;
    int fullscreen = 0;
    const Uint8 *keystates = SDL_GetKeyboardState(NULL);

    // initialize sdl components
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        printf("SDL could not initialize! Error: %s", SDL_GetError());
        exit(1);
    }

    // create screen and renderer
    if (SDL_CreateWindowAndRenderer(SCREEN_W, SCREEN_H, SDL_WINDOW_SHOWN, &window, &renderer) < 0) {
        printf("Renderer could not be created! Error: %s", SDL_GetError());
        exit(1);
    }

    SDL_SetWindowTitle(window, "${P_NAME}");
    SDL_SetWindowPosition(window, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);

    // set square measurements
    rect.x = rect.y = 50;
    rect.w = rect.h = 50;

    // main loop
    unsigned int loop_start, loop_end, delta;
    while (running) {
        // keeps the screen at 60fps
        loop_start = SDL_GetTicks();
        delta      = loop_start - loop_end;
        if (delta <= 1000/60.0) continue;

        // handling events
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) running = 0;
        }

        // handling keyboard events
        if (keystates[SDL_SCANCODE_ESCAPE]) running = 0;
        if (keystates[SDL_SCANCODE_F11])    fullscreen = !fullscreen;

        if (keystates[SDL_SCANCODE_RIGHT]) rect.x += 10;
        if (keystates[SDL_SCANCODE_LEFT])  rect.x -= 10;
        if (keystates[SDL_SCANCODE_DOWN])  rect.y += 10;
        if (keystates[SDL_SCANCODE_UP])    rect.y -= 10;

        // check boundaries
        if (rect.x < 0) rect.x = 0;
        if (rect.x > (SCREEN_W - rect.w)) rect.x = (SCREEN_W - rect.w);
        if (rect.y < 0) rect.y = 0;
        if (rect.y > (SCREEN_H - rect.h)) rect.y = (SCREEN_H - rect.h);

        // clear renderer with background color
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);

        // update window state if needed
        if (fullscreen) SDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN);
        else SDL_SetWindowFullscreen(window, 0);

        // draws the blue square
        SDL_SetRenderDrawColor(renderer, 40, 43, 200, 255);
        SDL_RenderFillRect(renderer, &rect);

        // draws a single pink pixel on the center of the screen
        SDL_SetRenderDrawColor(renderer, 156, 0, 156, 255);
        SDL_RenderDrawPoint(renderer, (SCREEN_W / 2), (SCREEN_H / 2));
        
        // update window with content
        SDL_RenderPresent(renderer);

        // keeping track of elapsed time
        loop_end = SDL_GetTicks();
    }

    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
EOD

### OPENGL
elif [[ $P_MODE == "opengl" ]]; then
    P_STDIO="false"
    P_LIB="${P_LIB} -lSDL2 -lGL"
    P_INC=`echo -e "${P_INC}#include <SDL2/SDL.h>\n#include <GL/gl.h>\n"`
    read -r -d '' P_CODE << EOD
int main(int argc, char** argv)
{
    const int SCREEN_W = 1280;
    const int SCREEN_H = 720;
    const int WINDOW_FLAGS = SDL_WINDOW_OPENGL;
    const Uint8 *keystates = SDL_GetKeyboardState(NULL);
    
    int running = 1;
    int fullscreen = 0;
    float FPS = 60.0;

    SDL_Window *window = NULL;
    SDL_Event event;

    // initialize sdl components
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        printf("SDL could not initialize! Error: %s", SDL_GetError());
        exit(1);
    }

    // create screen
    window = SDL_CreateWindow(
        "${P_NAME}",
        SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED,
        SCREEN_W,
        SCREEN_H,
        WINDOW_FLAGS);

    if (window == NULL) {
        printf("Window could not be created! Error: %s", SDL_GetError());
        exit(1);
    }

    // opengl configuration
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);

    // create opengl context and attach it to the window
    SDL_GLContext gl_context = SDL_GL_CreateContext(window);

    // main loop
    unsigned int loop_start, loop_end, delta;
    while (running) {
        // keeps the screen at 60fps
        loop_start = SDL_GetTicks();
        delta      = loop_start - loop_end;
        if (delta <= 1000 / FPS) continue;

        // handling events
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) running = 0;
        }

        // handling keyboard events
        if (keystates[SDL_SCANCODE_ESCAPE]) running = 0;
        if (keystates[SDL_SCANCODE_F11])    fullscreen = !fullscreen;

        // update window state if needed
        if (fullscreen) SDL_SetWindowFullscreen(window, WINDOW_FLAGS | SDL_WINDOW_FULLSCREEN_DESKTOP);
        else SDL_SetWindowFullscreen(window, WINDOW_FLAGS);

        // clear gl context
        glViewport(0, 0, SCREEN_W, SCREEN_H);
        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // draws rectangle
        glColor3f(0.0f, 0.0f, 0.666f);
        glRectf(-0.05f, 0.09f, 0.05f, -0.09f);

        // updating the screen
        SDL_GL_SwapWindow(window);

        // keeping track of elapsed time
        loop_end = SDL_GetTicks();
    }

    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
EOD

### GETOPT
elif [[ $P_MODE == "getopt" ]]; then
    P_STDIO="true"
    P_LIB="${P_LIB}"
    P_INC=`echo -e "${P_INC}#include <getopt.h>\n"`
    read -r -d '' P_CODE << EOD
void show_usage(char *bin)
{
    printf("$ %s <-m|-f> [-a AGE] [-n NAME] [-h HEIGHT]\n\n", bin);
    exit(1);
}

int main(int argc, char** argv)
{
    int option;
    int mflag = 0;
    int fflag = 0;
    int aflag = 0;
    int hflag = 0;
    char available_options[] = "mfn:a:h:";
    char *charname = "Guest";
    int age;
    double height;

    if (argc < 2) show_usage(argv[0]);

    opterr = 0; // suppress default 'invalid option' message
    while ((option = getopt(argc, argv, available_options)) != -1) {
        switch (option)
        {
            case 'm':
                if (fflag) show_usage(argv[0]);
                mflag = 1;
                break;
            
            case 'f':
                if (mflag) show_usage(argv[0]);
                fflag = 1;
                break;
            
            case 'n':
                if (optarg == NULL) show_usage(argv[0]);
                charname = optarg;
                break;
            
            case 'a':
                if (optarg == NULL) show_usage(argv[0]);
                aflag = 1;
                age = atoi(optarg);
                break;
            
            case 'h':
                if (optarg == NULL) show_usage(argv[0]);
                hflag = 1;
                height = atof(optarg);
                break;
            
            case '?':
            default:
                printf("Invalid option '-%c' was found!\n", optopt);
                break;
        }
    }

    if (!mflag && !fflag) show_usage(argv[0]);
    if (mflag) printf("Male character called %s!\n", charname);
    if (fflag) printf("Female character called %s!\n", charname);
    if (aflag) {
        if (age < 18) {
            printf("You should not be playing with this!\n");
            exit(1);
        }

        printf("You are %d years old... nice!\n", age);
    }

    if (hflag) {
        if (height < 1.0) {
            printf("Aren't you too small to be here?\n");
            exit(1);
        }

        printf("You are %.2fm tall!\n", height);
    }

    return 0;
}
EOD
fi

[[ "$P_STDIO" == "true" ]] && P_INC=`echo -e "${P_INC}#include <stdio.h>\n"`

# header
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Project: $P_NAME"

# creating project directory structure
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating directory structure..."
[ -d "$P_NAME" ] && duplicated
mkdir -p $P_NAME/src $P_NAME/lib $P_NAME/inc $P_NAME/obj $P_NAME/bin $P_NAME/doc

# Makefile
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating makefile"
cat >> $P_NAME/Makefile <<EOT
SDIR = ./src
ODIR = ./obj
LDIR = ./lib
IDIR = ./inc
BDIR = ./bin
DDIR = ./doc
MDIR = /usr/share/man/man3

BNAME = ${P_NAME}
LIBDIR = ${P_NAME}
LIBNAME= lib${P_NAME}

MK = mkdir -p
CC = gcc
CFLAGS = -I\$(IDIR)${P_LIB} -L\$(LDIR) -std=c11
CFLAGS += -fPIC -Wall -Wextra -Wpedantic \\
          -Wformat=2 -Wno-unused-parameter -Wshadow \\
          -Wwrite-strings -Wstrict-prototypes -Wold-style-definition \\
          -Wredundant-decls -Wnested-externs -Wmissing-include-dirs

# GCC warnings that Clang doesn't provide:
ifeq (\$(CC),gcc)
    CFLAGS += -Wjump-misses-init -Wlogical-op
endif

DEPS = \$(wildcard \$(IDIR)/*.h)
SOURCES = \$(wildcard \$(SDIR)/*.\$(CEXT)) \$(wildcard \$(SDIR)/**/*.\$(CEXT))
OBJECTS = \$(patsubst \$(SDIR)/%.c, \$(ODIR)/%.o, \$(SOURCES))

\$(BDIR)/\$(BNAME): \$(OBJECTS)
	\$(CC) -g -o \$@ \$^ \$(CFLAGS)

\$(ODIR)/%.o: \$(SDIR)/%.c \$(DEPS)
	\$(MK) \$(shell sh -c "find src -type d | sed -e s/src/obj/g")
	\$(CC) -g -c -o \$@ \$< \$(CFLAGS)

-include Makefile.deps

Makefile.deps:
	\$(CC) \$(CFLAGS) -MM \$(SOURCES) > Makefile.deps

.PHONY: clean doc
.SILENT: run clean

LIBFILES := \$(filter-out main.o,\$(wildcard \$(ODIR)/*.o))

clean:
	rm Makefile.deps
	rm -Rf dist
	rm -f \$(ODIR)/*.o *~ core \$(INCDIR)/*~ \$(BDIR)/* \$(DDIR)/*.gz

statlib:
	mkdir -p dist/static/headers
	ar rcs dist/static/\$(LIBNAME).a \$(LIBFILES)
	ranlib dist/static/\$(LIBNAME).a
	cp \$(IDIR)/*.h dist/static/headers

shared:
	mkdir -p dist/shared/headers
	\$(CC) -shared -o dist/shared/\$(LIBNAME).so \$(LIBFILES)
	cp \$(IDIR)/*.h dist/shared/headers

install:
	cp \$(BDIR)/\$(BNAME) /usr/bin

remove:
	rm /usr/bin/\$(BNAME)

libinstall:
	for H in \$(shell ls \$(DDIR)); do gzip -c \$(DDIR)/\$\${H} > \$(DDIR)/\$\${H}.gz; done
	mv \$(DDIR)/*.gz \$(MDIR)
	mkdir -p /usr/include/\$(LIBDIR)
	cp -Rf dist/shared/headers/* /usr/include/\$(LIBDIR)
	cp dist/shared/\$(LIBNAME).so /usr/lib

libremove:
	rm -Rf /usr/include/\$(LIBDIR)
	rm -f /usr/lib/\$(LIBNAME).so

run:
	chmod +x \$(BDIR)/\$(BNAME) && \$(BDIR)/\$(BNAME)

doc:
	man \$(DDIR)/\$(BNAME)
EOT


# man page
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating man page"
FDATE=`date +"%d %B %Y"`
cat >> $P_NAME/doc/$P_NAME <<EOT
.\" Manpage for ${P_NAME}.
.\" Contact ${USER}@${HOST} to correct errors or typos.
.TH man 1 "${FDATE}" "1.0" "${P_NAME} man page"
.SH NAME
${P_NAME} \- lorem ipsum dolor sit amet
.SH SYNOPSIS
${P_NAME} [OPTIONS...]
.SH DESCRIPTION
${P_NAME} is a template C software generated by the FactorC scaffolding script.
.SH OPTIONS
Description of all options that can change ${P_NAME} behavior.
.SH SEE ALSO
Any references you may want to include.
.SH BUGS
No known bugs.
.SH AUTHOR
Software written by ${USER} <${USER}@${HOST}>
EOT

# README file
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating README file"
cat >> $P_NAME/README.md <<EOT
# README

Demo readme file for project documentation.
EOT


# gitignore file
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating .gitignore"
cat >> $P_NAME/.gitignore <<EOT
build/
bin/
obj/
EOT


# main source file
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating placeholder code"
cat >> $P_NAME/src/main.c <<EOT
${P_INC}

${P_CODE}
EOT

echo -e "${BLUE}[${CYAN}!${BLUE}]${NC} All done :)\n"
struct_summary
echo -e "\n"
