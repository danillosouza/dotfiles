#!/bin/zsh

RED='\033[1;31m'
BLUE='\033[1;34m'
CYAN='\033[1;36m'
NC='\033[0m'

# get project parameters
P_NAME=$1
P_MODE=$2
P_DEMONAME=$P_NAME
G_NAME="FactorC"
G_VERSION="v0.6.2"

struct_summary()
{
    echo -e "\t${CYAN}./${P_DEMONAME}/${NC}"
    echo -e "\t├── ${CYAN}bin/${NC}"
    echo -e "\t│   └── ${CYAN}${P_DEMONAME}${NC}"
    echo -e "\t├── ${CYAN}cmake/${NC}"
    echo -e "\t├── ${CYAN}docs/${NC}"
    echo -e "\t│   └── ${P_DEMONAME}"
    echo -e "\t├── ${CYAN}include/${NC}"
    echo -e "\t│   └── pch.h"
    echo -e "\t├── ${CYAN}source/${NC}"
    echo -e "\t│   └── ${CYAN}${P_DEMONAME}/${NC}"
    echo -e "\t│       └── main.c"
    echo -e "\t├── ${CYAN}vendors/${NC}"
    echo -e "\t├── .gitignore"
    echo -e "\t├── CMakeLists.txt"
    echo -e "\t├── CMP.cmake"
    echo -e "\t├── cotire.cmake"
    echo -e "\t├── ${BLUE}build${NC}"
    echo -e "\t└── README.md"
    echo -e "\n\n"
    echo -e "\tBuild and run the project with the following commands:"
    echo -e "\t${CYAN}\$ cd ./${P_DEMONAME}${NC}"
    echo -e "\t${CYAN}\$ ./build [run]${NC}"
}

usage()
{
    echo -e "${BLUE}[${CYAN}?${BLUE}]${NC} Usage: $0 <PROJECT> [MODE]\n"
    struct_summary
    echo -e "\n"
    echo -e "\tPROJECT\t- Project name"
    echo -e "\tMODE\t- Create bare minimum project code for one of the available modes:\n"
    echo -e "\t\t* [curses]"
    echo -e "\t\t* [bearlib]"
    echo -e "\t\t* [sdl]"
    echo -e "\t\t* [opengl]"
    echo -e "\n"
    exit 1
}

duplicated()
{
    echo -e "${BLUE}[${RED}x${BLUE}]${NC} Directory already exists.\n"
    exit 1
}


## ===================================================================
## ENTRYPOINT
## ===================================================================


# print header
echo $CYAN
figlet "$G_NAME"
echo "C17 Project powered by CMake | Template $G_VERSION"
echo $NC
[[ -z "$P_NAME" ]] && P_DEMONAME="demo" && usage # terminate if no project supplied


# project header
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Project: $P_NAME"


# creating project directory structure
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating directory structure..."
[ -d "$P_NAME" ] && duplicated
mkdir -p $P_NAME/bin $P_NAME/cmake $P_NAME/docs $P_NAME/include $P_NAME/vendors $P_NAME/source/$P_NAME


## ===================================================================
## PROJECT MODE CONFIGURATIONS
## ===================================================================

BUILD_CONF=""   # aditional build information for the project mode dependencies
PCH_ADD=""      # aditional header content needed by the project mode
SRC_TEMPLATE="" # `main` function template for project mode, default if none


##
## [DEFAULT]
##
if [[ $P_MODE == "" ]]; then
    ## BUILD
    read -r -d '' BUILD_CONF << EOD
EOD

    ## PCH
    read -r -d '' PCH_ADD << EOD
EOD

    ## TEMPLATE
    read -r -d '' SRC_TEMPLATE << EOD
i32 main(i32 argc, char** argv)
{
    printf("Project ${P_NAME} built with ${G_NAME} ${G_VERSION}...\n");
    return 0;
}
EOD
fi


##
## NCURSES
##
if [[ $P_MODE == "curses" || $P_MODE == "ncurses" ]]; then
    ## BUILD
    read -r -d '' BUILD_CONF << EOD
##
## NCURSES
find_library(LIBCURSES curses REQUIRED)
target_link_libraries(\${EXEC_NAME} PUBLIC \${LIBCURSES})
EOD

    ## PCH
    read -r -d '' PCH_ADD << EOD
#undef _XOPEN_SOURCE
#undef _POSIX_C_SOURCE
#define _XOPEN_SOURCE   600
#define _POSIX_C_SOURCE 200112L

#include <unistd.h>
#include <ncurses.h>
EOD

    ## TEMPLATE
    read -r -d '' SRC_TEMPLATE << EOD
void wait_millis(i32 ms) { usleep(ms * 1000); }

i32 main(i32 argc, char **argv)
{
    bool running = true;
    char input;

    initscr();
    cbreak();
	noecho();
    curs_set(0);
    start_color();

    // id, foreground, background
    init_pair(1, COLOR_CYAN, COLOR_WHITE);
    
    u32 counter = 0;
    while (running) {
        clear();

        if (input) {
            attron(COLOR_PAIR(1));
            mvaddch(1, 1, input);
            attroff(COLOR_PAIR(1));
        }

        mvprintw(4, 10, "%d", counter);

        attron(A_BOLD);
        mvprintw(5, 10, "Hello World!");
        attroff(A_BOLD);
        refresh();

        timeout(0);
        input = getch();
        counter++;

        running = (input != 'q');
        wait_millis(1000 / 30);
    }
    
    endwin();
    return 0;
}
EOD
fi


##
## BEARLIB (SIMPLE)
##
if [[ $P_MODE == "bearlib" ]]; then
    ## BUILD
    read -r -d '' BUILD_CONF << EOD
##
## BEARLIBTERM
find_library(LIBBEARLIB BearLibTerminal REQUIRED)
target_link_libraries(\${EXEC_NAME} PUBLIC \${LIBBEARLIB})
EOD

    ## PCH
    read -r -d '' PCH_ADD << EOD
#include <BearLibTerminal.h>
EOD

    ## TEMPLATE
    read -r -d '' SRC_TEMPLATE << EOD
const u32 WINDOW_W = 1280;
const u32 WINDOW_H = 720;
const u32 CELL_W = 8;
const u32 CELL_H = 16;

i32 main(i32 argc, char **argv)
{
    // initialize bear terminal
    terminal_open();

    // config terminal (enter fullscreen with alt + enter)
    terminal_set("input: precise-mouse=true, mouse-cursor=false");
    terminal_setf("window: title='${P_NAME}', cellsize=%dx%d, size=%dx%d, resize-mode=fit, client-size=%dx%d",
        CELL_W, CELL_H, (WINDOW_W / CELL_W), (WINDOW_H / CELL_H), WINDOW_W, WINDOW_H);
    
    // configure fg & bg colors
    terminal_color(0xFF00FFFF);
    terminal_bkcolor(0xFF151515);

    // wait until user close the window by pressing 'q'
    u16 key;
    bool running = true;
    while (running) {
        terminal_clear();

        // print title text
        terminal_print(1, 1, "[color=red]Hello[/color] ${P_NAME}!");

        if (terminal_has_input()) {
            key = terminal_read();

            switch (key) {
                case TK_Q:
                    running = false;
                    break;
                
                default:
                    break;
            }
        }

        // update terminal
        terminal_refresh();
    }

    // exit bear terminal
    terminal_close();
    return 0;
}
EOD
fi


##
## SDL
##
if [[ $P_MODE == "sdl" ]]; then
    ## BUILD
    read -r -d '' BUILD_CONF << EOD
##
## SDL2 + SDL2_image
find_library(LIBSDL SDL2 REQUIRED)
find_library(LIBSDLIMG SDL2_image REQUIRED)
target_link_libraries(\${EXEC_NAME} PUBLIC \${LIBSDL} \${LIBSDLIMG})
EOD

    ## PCH
    read -r -d '' PCH_ADD << EOD
// SDL2
#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>
EOD

    ## TEMPLATE
    read -r -d '' SRC_TEMPLATE << EOD
i32 main(i32 argc, char** argv)
{
    const u32 SCREEN_W = 1280;
    const u32 SCREEN_H = 720;

    SDL_Window *window = NULL;
    SDL_Renderer *renderer = NULL;
    SDL_Event event;
    SDL_Rect rect;

    bool running = true;
    bool fullscreen = false;
    const u8 *keystates = SDL_GetKeyboardState(NULL);

    // initialize sdl components
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        printf("SDL could not initialize! Error: %s", SDL_GetError());
        exit(1);
    }

    // create screen and renderer
    if (SDL_CreateWindowAndRenderer(SCREEN_W, SCREEN_H, SDL_WINDOW_SHOWN, &window, &renderer) < 0) {
        printf("Renderer could not be created! Error: %s", SDL_GetError());
        exit(1);
    }

    SDL_SetWindowTitle(window, "${P_NAME}");
    SDL_SetWindowPosition(window, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED);

    // set square measurements
    rect.x = rect.y = 50;
    rect.w = rect.h = 50;

    // main loop
    u32 loop_start, loop_end, delta;
    while (running) {
        // keeps the screen at 60fps
        loop_start = SDL_GetTicks();
        delta      = loop_start - loop_end;
        if (delta <= 1000/60.0) continue;

        // handling events
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) running = false;
        }

        // handling keyboard events
        if (keystates[SDL_SCANCODE_ESCAPE]) running = false;
        if (keystates[SDL_SCANCODE_F11])    fullscreen = !fullscreen;

        if (keystates[SDL_SCANCODE_RIGHT]) rect.x += 10;
        if (keystates[SDL_SCANCODE_LEFT])  rect.x -= 10;
        if (keystates[SDL_SCANCODE_DOWN])  rect.y += 10;
        if (keystates[SDL_SCANCODE_UP])    rect.y -= 10;

        // check boundaries
        if (rect.x < 0) rect.x = 0;
        if (rect.x > (SCREEN_W - rect.w)) rect.x = (SCREEN_W - rect.w);
        if (rect.y < 0) rect.y = 0;
        if (rect.y > (SCREEN_H - rect.h)) rect.y = (SCREEN_H - rect.h);

        // clear renderer with background color
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);

        // update window state if needed
        if (fullscreen) SDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN);
        else SDL_SetWindowFullscreen(window, 0);

        // draws the blue square
        SDL_SetRenderDrawColor(renderer, 40, 43, 200, 255);
        SDL_RenderFillRect(renderer, &rect);

        // draws a single pink pixel on the center of the screen
        SDL_SetRenderDrawColor(renderer, 156, 0, 156, 255);
        SDL_RenderDrawPoint(renderer, (SCREEN_W / 2), (SCREEN_H / 2));
        
        // update window with content
        SDL_RenderPresent(renderer);

        // keeping track of elapsed time
        loop_end = SDL_GetTicks();
    }

    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
EOD
fi


##
## OPENGL + GLFW
##
if [[ $P_MODE == "opengl" ]]; then
    ## BUILD
    read -r -d '' BUILD_CONF << EOD
##
## OpenGL + GLFW
find_library(LIBOPENGL OpenGL REQUIRED)
find_library(LIBGLEW GLEW REQUIRED)
find_library(LIBGLFW glfw REQUIRED)
find_library(LIBDL dl REQUIRED)
target_link_libraries(\${EXEC_NAME} PUBLIC \${LIBOPENGL} \${LIBGLEW} \${LIBGLFW} \${LIBDL})
EOD

    ## PCH
    read -r -d '' PCH_ADD << EOD
// OpenGL
#include <string.h>
#include <GL/glew.h>
#include <GL/gl.h>
#include <GLFW/glfw3.h>
EOD

    ## TEMPLATE
    read -r -d '' SRC_TEMPLATE << EOD
// callback for window resizing
void framebuffer_size_callback(GLFWwindow *window, i32 width, i32 height)
{
    glViewport(0, 0, width, height);
}


// handle user input
void processInput(GLFWwindow *window)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
        glfwSetWindowShouldClose(window, true);
    }
}


i32 main(i32 argc, char **argv)
{
    const u32 WINDOW_W = 1280, WINDOW_H = 720;
    GLFWwindow* window;

    // Initialize the library
    if (! glfwInit())
        return -1;
    
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    // Create a windowed mode window and its OpenGL context
    window = glfwCreateWindow(WINDOW_W, WINDOW_H, "HelloGL", NULL, NULL);
    if (! window) {
        glfwTerminate();
        return -1;
    }

    // Make the window's context current
    glfwMakeContextCurrent(window);

    // Initialize GLEW
    GLenum glew_err = glewInit();
    if (glew_err != GLEW_OK) {
        glfwTerminate();
        return -1;
    }

    // Defining viewport for opengl rendering
    glViewport(0, 0, WINDOW_W, WINDOW_H);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    //
    // SHADERS
    //

    // Vertex Shader
    const char *vertexShaderSource = "#version 330 core\n"
        "layout (location = 0) in vec3 pos;\n"
        "void main()\n"
        "{\n"
        "   gl_Position = vec4(pos.x, pos.y, pos.z, 1.0f);\n"
        "}\0";

    u32 vertexShader;
    i32 vertexShaderSourceSize = strlen(vertexShaderSource);
    vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSource, &vertexShaderSourceSize);
    glCompileShader(vertexShader);

    // Fragment Shader
    const char *fragmentShaderSource = "#version 330 core\n"
        "out vec4 color;\n"
        "void main()\n"
        "{\n"
        "   color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
        "}\0";

    u32 fragmentShader;
    i32 fragmentShaderSourceSize = strlen(fragmentShaderSource);
    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, &fragmentShaderSourceSize);
    glCompileShader(fragmentShader);

    // Shader Program
    u32 shaderProgram;
    shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);

    // Use program and delete shader objects once linked
    glUseProgram(shaderProgram);
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    //
    // VERTEX DATA
    //
    
    // Creating triangle vertices
    f32 vertices[] = {
         0.5f,  0.5f, 0.0f,  // top right
         0.5f, -0.5f, 0.0f,  // bottom right
        -0.5f, -0.5f, 0.0f,  // bottom left
        -0.5f,  0.5f, 0.0f   // top left
    };

    u32 indices[] = {
        0, 1, 3, // first triangle
        1, 2, 3  // second triangle
    };

    // Vertex Array Object
    u32 VAO;
    glGenVertexArrays(1, &VAO);
    glBindVertexArray(VAO);

    // Element/Index Buffer Object
    u32 EBO;
    glGenBuffers(1, &EBO);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

    // Vertex Buffer Object
    u32 VBO; // store the object id
    glGenBuffers(1, &VBO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    // Tells OpenGL how to interpret vertex data
    i32 index = 0; // data starts at index 0, as stated in the shader (location = 0)
    i32 size = 3;  // size of the vertex attribute, in this case 3 for a vec3 (x, y, z)
    i32 stride = 3 * sizeof(f32); // space between consecutive attributes, we advance in steps of 3 as it is tightly packed
    glVertexAttribPointer(index, size, GL_FLOAT, GL_FALSE, stride, (void *) 0);
    glEnableVertexAttribArray(index);

    // unbind buffers
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    //
    // MAIN LOOP
    //

    // Loop until the user closes the window
    while (! glfwWindowShouldClose(window)) {
        // Process user input
        processInput(window);

        // Render here
        glClearColor(0.2f, 0.2f, 0.2f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // Draw elements to the screen
        glBindVertexArray(VAO);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);

        // glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); // fireframe mode
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        glDrawElements(GL_TRIANGLES, sizeof(indices) / sizeof(u32), GL_UNSIGNED_INT, 0);

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
        glBindVertexArray(0);

        // Swap front and back buffers
        glfwSwapBuffers(window);

        // Poll for and process events
        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}
EOD
fi


## ===================================================================
## CREATING PROJECT SOURCE FILES
## ===================================================================

##
## source/<project>/main.c
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}source/$P_NAME/main.c${NC}"
cat >> $P_NAME/source/$P_NAME/main.c <<EOT
#include "pch.h"

${SRC_TEMPLATE}
EOT

##
## include/pch.h
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}include/pch.h${NC}"
cat >> $P_NAME/include/pch.h <<EOT
#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

${PCH_ADD}

// DATA DEFS
typedef uint8_t   u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t   i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

typedef float  f32;
typedef double f64;
EOT

##
## Man page
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating man page"
FDATE=`date +"%d %B %Y"`
cat >> $P_NAME/docs/$P_NAME <<EOT
.\" Manpage for ${P_NAME}.
.\" Contact ${USER}@${HOST} to correct errors or typos.
.TH man 1 "${FDATE}" "1.0" "${P_NAME} man page"
.SH NAME
${P_NAME} \- lorem ipsum dolor sit amet
.SH SYNOPSIS
${P_NAME} [OPTIONS...]
.SH DESCRIPTION
${P_NAME} is a template C++ software generated by the ${G_NAME} ${G_VERSION}.
.SH OPTIONS
Description of all options that can change ${P_NAME} behavior.
.SH SEE ALSO
Any references you may want to include.
.SH BUGS
No known bugs.
.SH AUTHOR
Software written by ${USER} <${USER}@${HOST}>
EOT


##
## .gitignore
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}.gitignore${NC}"
cat >> $P_NAME/.gitignore <<EOT
.vscode/
cmake/*
bin/*
*.sh
EOT


##
## README file
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}README.md${NC}"
cat >> $P_NAME/README.md <<EOT
# README

Demo readme file for project documentation.
EOT


## ===================================================================
## CREATING PROJECT BUILD FILES
## ===================================================================


##
## CMakeLists.txt
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}CMakeLists.txt${NC}"
cat >> $P_NAME/CMakeLists.txt <<EOT
## ====================================================
## BASIC PROJECT SETUP
## ====================================================


##
## Local dependencies
include(CPM.cmake)    # link dependencies from github
include(cotire.cmake) # manage precompiled headers


##
## CMake and cpp versions
cmake_minimum_required(VERSION 3.9.1)
set(CMAKE_C_STANDARD 17)
set(CMAKE_C_STANDARD_REQUIRED ON)


##
## Define project
set(EXEC_NAME ${P_NAME})
project(\${EXEC_NAME} VERSION 1.0 LANGUAGES C)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \${CMAKE_CURRENT_SOURCE_DIR}/bin) # ship libraries with the binary


##
## Environment Specific Code
if (NOT CMAKE_BUILD_TYPE STREQUAL "Release")
    set(CMAKE_BUILD_TYPE Debug)
    add_compile_definitions(ENABLE_CUSTOM_ASSERTS)  # don't enable this feature for release
endif ()

if(CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS)
    install(PROGRAMS ${CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS} DESTINATION bin COMPONENT System)
endif(CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS)

set(CMAKE_INSTALL_RPATH "$ORIGIN")
set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)


##
## Build Project
set(SRC_DIR \${CMAKE_CURRENT_SOURCE_DIR}/source)
set(HDR_DIR \${CMAKE_CURRENT_SOURCE_DIR}/source \${CMAKE_CURRENT_SOURCE_DIR}/include)
file(GLOB_RECURSE SRCS \${SRC_DIR}/*.c)
add_executable(\${EXEC_NAME} \${SRCS})
target_include_directories(\${EXEC_NAME} PUBLIC \${SRC_DIR})
target_include_directories(\${EXEC_NAME} PUBLIC \${HDR_DIR})

set_target_properties(\${EXEC_NAME} PROPERTIES RUNTIME_OUTPUT_DIRECTORY "\${CMAKE_CURRENT_SOURCE_DIR}/bin")
set_target_properties(\${EXEC_NAME} PROPERTIES LIBRARY_OUTPUT_DIRECTORY "\${CMAKE_CURRENT_SOURCE_DIR}/bin")


## ====================================================
## EXTERNAL DEPENDENCIES
## ====================================================


${BUILD_CONF}


##
## Add dependencies via `pkg-config`
#find_package(PkgConfig)
#if (PKG_CONFIG_FOUND)
#    pkg_check_modules(XFT "xft")
#
#    if (XFT_FOUND)
#        add_definitions(${XFT_CFLAGS} ${XFT_CFLAGS_OTHER})
#    endif()
#endif()
#target_link_libraries(${EXEC_NAME} PUBLIC ${XFT_LIBRARIES})


##
## Build static library and link it to the executable
#set(LIBDEMO_NAME demo)
#set(LIBDEMO_SRC_DIR \${CMAKE_CURRENT_SOURCE_DIR}/source/demo/)
#set(LIBDEMO_HDR_DIR \${CMAKE_CURRENT_SOURCE_DIR}/source/demo/)
#
#file(GLOB_RECURSE LIBDEMO_SRC_FILES \${LIBDEMO_SRC_DIR}/*.c)
#add_library(\${LIBDEMO_NAME} STATIC \${LIBDEMO_SRC_FILES})
#
#target_include_directories(\${LIBDEMO_NAME} PUBLIC \${LIBDEMO_HDR_DIR})
#target_include_directories(\${LIBDEMO_NAME} PUBLIC \${HDR_DIR})
#target_link_libraries(\${EXEC_NAME} PUBLIC \${LIBDEMO_NAME})


##
## Link external library from system path
#find_library(LIBSDL SDL2)
#target_link_libraries(\${EXEC_NAME} PUBLIC \${LIBSDL})


##
## Link external library from custom system path
## (used with a param like: "cmake -DCMAKE_PREFIX_PATH=/your/path ..)
#find_library(LIBCURL
#    NAMES curl curllib libcurl_imp curllib_static
#    HINTS "\${CMAKE_PREFIX_PATH}/curl/lib"
#)
#target_link_libraries(\${EXEC_NAME} PUBLIC \${LIBCURL})


##
## Link external library from github
#CPMAddPackage("gh:catchorg/Catch2@2.13.4")
#target_link_libraries(\${EXEC_NAME} PUBLIC Catch2)


##
## Link external header-only library
#set(LIBSTB_HDR_DIR \${CMAKE_CURRENT_SOURCE_DIR}/vendors/stb)
#target_include_directories(\${EXEC_NAME} PUBLIC \${LIBSTB_HDR_DIR})


## ====================================================
## BUILD UTILS
## ====================================================


## copy resources to the exec directory
#file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/resources DESTINATION ${CMAKE_CURRENT_SOURCE_DIR}/bin)


##
## Creating precompiled headers
set_target_properties(\${EXEC_NAME} PROPERTIES COTIRE_CXX_PREFIX_HEADER_INIT "\${CMAKE_CURRENT_SOURCE_DIR}/include/pch.h")
cotire(\${EXEC_NAME})


##
## Add 'make run' command
add_custom_target(run
    COMMAND \${CMAKE_CURRENT_SOURCE_DIR}/run.sh
    DEPENDS \${CMAKE_CURRENT_SOURCE_DIR}/bin/\${EXEC_NAME}
    WORKING_DIRECTORY \${CMAKE_PROJECT_DIR}
)


##
## Add 'make clear' command
add_custom_target(clear
    COMMAND rm -Rf \${CMAKE_CURRENT_SOURCE_DIR}/bin/* \${CMAKE_CURRENT_SOURCE_DIR}/cmake/* \${CMAKE_CURRENT_SOURCE_DIR}/*.sh
    WORKING_DIRECTORY \${CMAKE_PROJECT_DIR}
)
EOT


##
## CPM.cmake (0.34.3) - try download first, or else build local
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating CMP.cmake"
(cd ${P_NAME} && curl -LJO --silent https://github.com/cpm-cmake/CPM.cmake/releases/download/v0.34.3/CPM.cmake && cd ..)

if [ ! -f $P_NAME/CPM.cmake ]; then
    cat >> $P_NAME/CPM.cmake <<EOT
set(CPM_DOWNLOAD_VERSION 0.34.3)

if(CPM_SOURCE_CACHE)
  # Expand relative path. This is important if the provided path contains a tilde (~)
  get_filename_component(CPM_SOURCE_CACHE \${CPM_SOURCE_CACHE} ABSOLUTE)
  set(CPM_DOWNLOAD_LOCATION "\${CPM_SOURCE_CACHE}/cpm/CPM_\${CPM_DOWNLOAD_VERSION}.cmake")
elseif(DEFINED ENV{CPM_SOURCE_CACHE})
  set(CPM_DOWNLOAD_LOCATION "\$ENV{CPM_SOURCE_CACHE}/cpm/CPM_\${CPM_DOWNLOAD_VERSION}.cmake")
else()
  set(CPM_DOWNLOAD_LOCATION "\${CMAKE_BINARY_DIR}/cmake/CPM_\${CPM_DOWNLOAD_VERSION}.cmake")
endif()

if(NOT (EXISTS \${CPM_DOWNLOAD_LOCATION}))
  message(STATUS "Downloading CPM.cmake to \${CPM_DOWNLOAD_LOCATION}")
  file(DOWNLOAD
       https://github.com/cpm-cmake/CPM.cmake/releases/download/v\${CPM_DOWNLOAD_VERSION}/CPM.cmake
       \${CPM_DOWNLOAD_LOCATION}
  )
endif()

include(\${CPM_DOWNLOAD_LOCATION})
EOT
fi


##
## Build script on the root dir
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}build${NC} tool ${BLUE}($ ./build [run])${NC}"
cat >> $P_NAME/build <<EOT
#!/bin/zsh

ARG=\$1
BINARY="${P_NAME}"
ROOT_DIR="\${0:a:h}"
BUILD_DIR="\$ROOT_DIR/cmake"
DIST_DIR="\$ROOT_DIR/bin"

cd "\$BUILD_DIR"
cmake ..
make

cd "\$ROOT_DIR"; echo"";
if [[ \$ARG == "run" ]] exec "\$DIST_DIR/\$BINARY"
if [[ \$ARG == "dbg" ]] gdb "\$DIST_DIR/\$BINARY"
EOT
chmod +x $P_NAME/build


##
## cotire.cmake (v1.8.1)
echo "${BLUE}[${CYAN}+${BLUE}]${NC} Creating ${CYAN}cotire.cmake${NC}"
(cd ${P_NAME} && curl -LJO --silent https://github.com/sakra/cotire/releases/download/cotire-1.8.1/cotire.cmake && cd ..)


##
## Terminated
echo -e "${BLUE}[${CYAN}!${BLUE}]${NC} All done :3\n"
struct_summary
echo -e "\n"
